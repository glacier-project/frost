target Python;

import FrostInterface from "FrostInterface.lf" 

reactor FrostDataModel(data_model_path = "", update_interval=1 s) extends FrostInterface{
    '''Reactor implementing the common logic used to handle incoming data model-related messages, such as variable updates, method invocations, and protocol registrations.
    
    Args:
        data_model_path (str): Path to the data model file.
        update_interval (int): Interval for checking updates in the data model.

    Attributes:
        data_model (DataModel): The data model used by the reactor.
        protocol_mng (FrostProtocolMng): The protocol manager for handling protocol messages.
    '''

    timer check_update(0, update_interval)

    state data_model
    state protocol_mng

    method _get_reactor_name(){=
        '''Get the name of the reactor.'''
        return self.data_model.name
    =}

    // @label _initialize_data_model
    reaction (startup) {=
        '''Initializes the FrostDataModel reactor.
        
        Args:
            startup (input): The event that triggers the configuration of the message filter.
        '''
        self.data_model = DataModelBuilder().get_data_model(self.data_model_path)
        self.protocol_mng = FrostProtocolMng(self.data_model)
    =}

    # TODO: why we need this?
    state method_queue = []
    // @label _process_requests
    reaction (message_filter.requests) -> channel_out{=
        '''Handle a request message related to the data model.

        Args:
            message_filter.requests (input): The input port for request messages.
        Returns:
            channel_out (output): The output port for processed messages.
        '''
        for bank_index, message in message_filter.requests.value:
            if message.header.namespace == MsgNamespace.PROTOCOL or message.target != self.name:
                return 0

            self.logger.debug(f"Handling data model request: {message}")

            if message.header.namespace == MsgNamespace.METHOD and message.header.msg_name == MethodMsgName.INVOKE:
                method_node = self.data_model.get_node(message.payload.node)
                self.logger.debug(f"method: {method_node.name} is_async: {method_node.is_async()}")

                # TODO: this check here should be simplified 
                if isinstance(method_node, MethodNode) and not isinstance(method_node, AsyncMethodNode) and not isinstance(method_node, CompositeMethodNode):
                    self.method_queue.append(message)
                    return 0

            # TODO: Handle other request types here!
            response = self.protocol_mng.handle_request(message)
            self._set_channel_out_port(response, channel_out)
    =}


    // @label _send_data_model_updates
    reaction (check_update) -> channel_out{=
        '''Check if there are any updates in the data model and send them to the subscribers.
        
        Args:
            check_update (input): The event that triggers the check for updates.

        Returns:
            channel_out (output): The output port for sending update messages.
        '''
        
        update_messages = list(self.protocol_mng.get_update_messages())
        if not update_messages:
            return 0

        self._set_channel_out_port(update_messages, channel_out)
        self.protocol_mng.clear_update_messages()
            
    =}

}