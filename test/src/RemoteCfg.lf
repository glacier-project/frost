target Python{
    fast: true,
    timeout: 1 h 
}

import FrostMachine from "../../src/lib/FrostMachine.lf"
import FrostBus from "../../src/lib/FrostBus.lf"
import FrostReactor from "../../src/lib/FrostReactor.lf"

preamble{=
    import uuid
    import os
    os.environ["FROST_CONFIG"] = "resources/remote_cfg/frost_config.yml"
    from frost import *
    from machine_data_model.protocols.frost_v1.frost_message import FrostMessage
    from machine_data_model.protocols.frost_v1.frost_header import MsgType, MsgNamespace, ProtocolMsgName, FrostHeader, MethodMsgName, VariableMsgName
    from machine_data_model.protocols.frost_v1.frost_payload import VariablePayload, ProtocolPayload, MethodPayload, ErrorPayload
    from machine_data_model.protocols.frost_v1.frost_protocol_mng import FrostProtocolMng
    from machine_data_model.builder.data_model_builder import DataModelBuilder
    from machine_data_model.protocols.protocol_mng import Message
    from machine_data_model.nodes.method_node import MethodNode, AsyncMethodNode
    from machine_data_model.nodes.composite_method.composite_method_node import CompositeMethodNode
    from machine_data_model.nodes.variable_node import NumericalVariableNode, StringVariableNode, BooleanVariableNode, ObjectVariableNode
    from machine_data_model.nodes.folder_node import FolderNode
=}

reactor Tester extends FrostReactor{

    state correlation_id

    method create_method_request(s, t, method_path, args, kwargs){=

        return FrostMessage(
            sender=s,
            target=t,
            identifier=str(uuid.uuid4()),
            header=FrostHeader(
                type=MsgType.REQUEST,
                version=(1, 0, 0),
                namespace=MsgNamespace.METHOD,
                msg_name=MethodMsgName.INVOKE,
            ),
            payload=MethodPayload(
                node=method_path,
                args=args,
                kwargs=kwargs
            )
        )
    =}

    reaction(connected_to_bus) -> channel_out{=

        msg = self.create_method_request(
            s="tester",
            t="machine",
            method_path="Machine/RemoteProduct",
            args=[5],
            kwargs={}
        )
        self.correlation_id = msg.correlation_id
        self._set_channel_out_port(msg, channel_out)
    =}

    reaction(message_filter.responses) {=
        for bank_index, message in message_filter.responses.value:

            if message.correlation_id != self.correlation_id:
                continue

            self.logger.info(f"Received response: {message}")
    =}
}

reactor Machine extends FrostMachine{
    
}

reactor RemoteMachine extends FrostMachine{

    state remote_variable
    state remote_product

    method product(n1, n2){=
        self.logger.info(f"Calculating product of {n1} and {n2}")
        return n1 * n2
    =}

    reaction(startup) {=
        self.logger.info("RemoteMachine started.")

        self.remote_variable = self.data_model.get_node("RemoteMachine/RemoteVariable")
        self.remote_product = self.data_model.get_node("RemoteMachine/RemoteProduct")
        self.remote_product.callback = self.product
    =}
}

main reactor{
    m = new Machine(name="machine")   
    t = new Tester(name="tester")
    remote_m = new RemoteMachine(name="remote_machine")
    bus = new FrostBus(name="bus", width=3)

    m.channel_out, t.channel_out, remote_m.channel_out -> bus.channel_in
    bus.channel_out -> m.channel_in, t.channel_in, remote_m.channel_in after 0
}