target Python{
    fast: true,
    timeout: 30 min
}

import FrostScheduler from "../../src/lib/scheduler/FrostScheduler.lf"
import FrostBus from "../../src/lib/FrostBus.lf"
import FrostMachine from "../../src/lib/FrostMachine.lf"

preamble{=
    import uuid
    print(f"Frost library imported {os.environ.get('FROST_CONFIG')}")
    from frost import *
    from frost_sheet.generator.instance_generator import load_instance_from_json
    from frost_sheet.solver.genetic_solver import GeneticAlgorithmSolver
    from frost_sheet.visualization.instance_dot_exporter import (
        export_instance_to_dot,
        render_dot_to_file,
    )
=}
 
reactor Scheduler extends FrostScheduler{

    state scheduling_instance
    logical action task_completed
    logical action start_task
    timer check_ready_tasks(1 sec, 1 sec)

    reaction(startup) {=
        self.scheduling_instance = load_instance_from_json(self.scheduling_instance)
        solver = GeneticAlgorithmSolver(instance=self.scheduling_instance)
        solution = solver.schedule()

        for task in solution.get_tasks():
            self.logger.warning(f"Scheduled task: {task}")
    =}

    method create_method_request(s, t, method_path, args, kwargs){=

        return FrostMessage(
            sender=s,
            target=t,
            identifier=str(uuid.uuid4()),
            header=FrostHeader(
                type=MsgType.REQUEST,
                version=(1, 0, 0),
                namespace=MsgNamespace.METHOD,
                msg_name=MethodMsgName.INVOKE,
            ),
            payload=MethodPayload(
                node=method_path,
                args=args,
                kwargs=kwargs
            )
        )
    =}

    reaction(connected_to_bus) -> channel_out{=

        # msg = self.create_method_request(
        #     s="scheduler",
        #     t="machine_1",
        #     method_path="Machine/StartTask1",
        #     args=[],
        #     kwargs={}
        # )
        # self.logger.info(f"Sending request: {msg}")
        # self._set_channel_out_port(msg, channel_out)
        # msg = self.create_method_request(
        #     s="scheduler",
        #     t="machine_2",
        #     method_path="Machine/StartTask2",
        #     args=[],
        #     kwargs={}
        # )
        # self.logger.info(f"Sending request: {msg}")
        # self._set_channel_out_port(msg, channel_out)
    =}

    reaction(check_ready_tasks){=
        self.logger.debug("Checking for ready tasks...")
        ready_tasks = self.scheduling_instance.get_ready_tasks()

    =}

    // @label run_task
    reaction(start_task){=
        self.logger.warning(f"Starting task: {task}")
    =}

    // @label task_completed
    reaction(task_completed){=
        self.logger.warning(f"Task completed: {task}")
    =}
}

reactor Machine extends FrostMachine{
 
    state busy
    state operation_mode
    state mode_duration = 0
    state n_task_completed
    timer check_mode_request(1 sec, 1 sec)
    logical action to_idle

    method switch_to_mode(duration, mode_id){=
        if self.operation_mode.value > 0:
            self.logger.warning(f"Machine is busy in mode {self.operation_mode.value}. Cannot switch to mode {mode_id}")
            return False

        self.operation_mode.value = mode_id
        self.mode_duration = duration
        self.logger.info(f"New operation mode set: {mode_id}")
        return True
    =}

    reaction(check_mode_request) -> to_idle{=
        if self.operation_mode.value <= 0 or self.busy.value:
            return 0

        self.logger.info(f"Operation mode {self.operation_mode.value} active. Switching to idle in {self.mode_duration} msec")
        self.busy.value = True
        to_idle.schedule(SECS(self.mode_duration))
    =}

    reaction(to_idle) {=
        self.busy.value = False
        self.operation_mode.value = 0
        self.n_task_completed.value += 1
        self.logger.info(f"Machine is now idle. Total tasks completed: {self.n_task_completed.value}")
    =}

    reaction(startup) {=
        self.busy = self.data_model.get_node("/Machine/Busy")
        self.operation_mode = self.data_model.get_node("/Machine/OperationMode")
        self.n_task_completed = self.data_model.get_node("/Machine/#TasksCompleted")
        switch_to_mode = self.data_model.get_node("/Machine/SwitchToOperationMode")
        switch_to_mode.callback = self.switch_to_mode
    =}

}

main reactor TestScheduler{
    s = new Scheduler(name="scheduler")
    bus = new FrostBus(name="bus", width=3)
    machine_1 = new Machine(name="machine_1")
    machine_2 = new Machine(name="machine_2")

    s.channel_out, machine_1.channel_out, machine_2.channel_out -> bus.channel_in
    bus.channel_out -> s.channel_in, machine_1.channel_in, machine_2.channel_in after 0
}