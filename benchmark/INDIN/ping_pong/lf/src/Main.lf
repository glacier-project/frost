/**
 * Basic benchmark from the Savina benchmark suite that is intended to measure
 * message-passing overhead. This is based on
 * https://www.scala-lang.org/old/node/54 See
 * https://shamsimam.github.io/papers/2014-agere-savina.pdf.
 *
 * Ping introduces a 1 nsec delay using a logical action to break the
 * causality loop.
 *
 * To get a sense, some (informal) results for 1,000,000 ping-pongs on my Mac:
 *
 * - Unthreaded: 97 msec
 * - Threaded: 265 msec
 *
 * There is no parallelism in this application, so it does not benefit from
 * being being threaded, just some additional overhead.
 *
 * These measurements are total execution time, including startup and shutdown.
 * These are about an order of magnitude faster than anything reported in the
 * paper.
 */
 target Python{
    fast: True,
    files: [
        ../../config/utils/l_formatter.py, 
        ../../config/utils/time_utils.py, 
        ../../config/utils/singleton_meta.py, 
        ../../config/utils/g_preamble.py, 
        ../../config/utils/handle_recipe.py
    ],
}

preamble{=
    from g_preamble import *
=}


reactor Ping {
    input receive
    output send
    state pingsLeft = 10
    logical action serve(1 nsec)
    state counter = 0
    reaction(startup) -> serve {=
        serve.schedule(0)
    =}

    reaction(serve) -> send {=
        send.set(self.pingsLeft)
        self.pingsLeft -= 1
    =}
    
    reaction(receive) -> serve {=
        if (self.pingsLeft > 0):
            serve.schedule(0)
        elif (self.pingsLeft == 0):
            self.pingsLeft = 10
            self.counter += 1
            if (self.counter == NUM_RUNS):
                request_stop()
            
            serve.schedule(0)
    =}
}

reactor Pong {
    input receive
    output send
    state count = 0
    state expected = 10

    reaction(receive) -> send {=
        if (receive.value == 10):
            self.count = 0
        
        self.count += 1
        send.set(receive.value)
    =}
}

main reactor {

    preamble{=
        handler = logging.StreamHandler()
        handler.setFormatter(LFormatter(lf.time.logical_elapsed, TimeFormat.MSECS))
        logger = logging.getLogger()
        logger.setLevel(logging.ERROR)
        logger.addHandler(handler)
    =}
    ping = new Ping()
    pong = new Pong()
    ping.send -> pong.receive
    pong.send -> ping.receive
}