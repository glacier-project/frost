target Python


reactor Scheduler(recipe_path = "recipes/recipe.yaml", 
                condition_path = "recipes/conditions.yaml"
){

    input channel_in
    output channel_out
    state name = {="Scheduler"=}
    state recipe = {=[
        GlacierMessage(
            sender=self.name,
            target="Ring",
            identifier=str(uuid.uuid4()),
            header=GlacierHeader(
                type=MsgType.REQUEST,
                version=(1, 0, 0),
                namespace=MsgNamespace.METHOD,
                msg_name=MethodMsgName.INVOKE,
            ),
            payload=MethodPayload(node = "Ring/ring", args = [0])
        )]=} 
    state conditions = {=[Condition(machine = "Ring", header = "METHOD", node = "out", value = 5)]=}  

    logical action routine

    method generate_bus_registration_message(){=
        """
        Generates a `REGISTER` message to initiate the registration process with the CommonBus.

        This method constructs a `GlacierMessage` that requests registration in the 
        communication system. The message is addressed to the `"CommonBus"` and follows 
        the `PROTOCOL` namespace with the `REGISTER` message name.

        :return: A `GlacierMessage` representing the registration request.
        """
        return GlacierMessage(
            sender=self.name,
            target="CommonBus",
            identifier=str(uuid.uuid4()),
            header=GlacierHeader(
                type=MsgType.REQUEST,
                version=(1, 0, 0),
                namespace=MsgNamespace.PROTOCOL,
                msg_name=ProtocolMsgName.REGISTER,
            ),
            payload=ProtocolPayload(),
        )
    =}

    reaction(startup)-> channel_out, routine{=
        channel_out.set(self.generate_bus_registration_message())
        self.logger = logging.getLogger("Scheduler")
        routine.schedule(NSEC(0))
    =}
    state i = 0
    reaction(routine)-> channel_out{=
        if self.recipe:
            self.logger.warning(f"Scheduler: {self.name} is sending {self.recipe[self.i]}")
            channel_out.set(self.recipe[self.i])
            self.i += 1
    =}
    state counter = 0
    reaction(channel_in) -> routine{=
        messages = channel_in.value
        assert isinstance(messages, list) and all(isinstance(item, Message) for item in messages), f"Received invalid messages: {messages}"
        for message in messages:
            if message.header.matches(MsgType.REQUEST, MsgNamespace.PROTOCOL, ProtocolMsgName.REGISTER):
                self.logger.warning(f"{message.sender} requests to register to {message.target}.")
                continue
            if message.header.matches(MsgType.RESPONSE, MsgNamespace.PROTOCOL, ProtocolMsgName.REGISTER):
                self.logger.warning(f"{message.sender} notify registration to {message.target}.")
                continue
            else:
                self.logger.warning(f"{message.sender} to {message.target} with header {message.header} and payload {message.payload}\n")

            if self.conditions:
                if self.conditions[0].check_condition(message):
                    routine.schedule(NSEC(0))
                    if self.i == 1:
                        self.counter += 1            
                        self.i = 0
                        if self.counter == NUM_RUNS:
                            request_stop()
    =}

}